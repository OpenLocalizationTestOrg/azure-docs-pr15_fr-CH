<properties
   pageTitle="Réessayer conseils généraux | Microsoft Azure"
   description="Conseils sur les nouvelles tentatives de traitement des erreurs transitoires."
   services=""
   documentationCenter="na"
   authors="dragon119"
   manager="christb"
   editor=""
   tags=""/>

<tags
   ms.service="best-practice"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="07/13/2016"
   ms.author="masashin"/>

# <a name="retry-general-guidance"></a>Réessayer conseils généraux

[AZURE.INCLUDE [pnp-header](../includes/guidance-pnp-header-include.md)]

## <a name="overview"></a>Vue d’ensemble

Toutes les applications qui communiquent avec les ressources et les services à distance doivent être sensibles aux défaillances temporaires. C’est particulièrement le cas pour les applications qui s’exécutent dans le nuage, où la nature de l’environnement et de la connectivité via Internet signifie que ces types d’erreurs sont susceptibles d’être plus souvent rencontrées. Défaillances temporaires incluent la perte momentanée de la connectivité réseau pour les composants et services, l’indisponibilité temporaire d’un service, ou des délais d’expiration qui se produisent lorsqu’un service est occupé. Ces erreurs sont souvent correction automatique, et si l’action est répétée après un délai approprié, il est probable que réussir.

Ce document traite des directives générales pour la gestion des erreurs en régime transitoire. Pour plus d’informations sur la gestion des défaillances temporaires lors de l’utilisation des services Microsoft Azure, consultez [Azure spécifiques au service réessayer d’instructions](best-practices-retry-service-specific.md).

## <a name="why-do-transient-faults-occur-in-the-cloud"></a>Pourquoi les défaillances temporaires se produisent dans le nuage ?

Défaillances temporaires peuvent se produire dans n’importe quel environnement, sur n’importe quel système d’exploitation ou la plate-forme et tout type d’application. Dans les solutions locales, infrastructure sur site, les performances et la disponibilité de l’application et de ses composants est généralement maintenue grâce à la redondance du matériel coûteux et souvent sous-exécuter sur, et sont des composants et des ressources situé près chacun un autre. Pendant une défaillance ainsi moins probable, il peut toujours entraîner des défaillances temporaires - et même une panne par le biais des événements imprévus, tels que le bloc d’alimentation externe ou de problèmes réseau ou d’autres scénarios de reprise après sinistre.

L’hébergement cloud, y compris les systèmes de cloud privé, contribuent à une disponibilité globale en utilisant des ressources partagées, la redondance, le basculement sur incident automatique et allocation dynamique des ressources sur un très grand nombre de nœuds de calcul de nomenclature de produit. Toutefois, la nature de ces environnements peut signifier que les défaillances temporaires sont plus susceptibles de se produire. Il existe plusieurs raisons à cela :

* Nombre de ressources dans un environnement de cloud est partagée, et accès à ces ressources est soumis à la limitation pour protéger la ressource. Certains services refuse les connexions lorsque la charge atteint un niveau spécifique, ou un débit maximal est atteint, afin de permettre le traitement des demandes existantes et pour maintenir les performances du service pour tous les utilisateurs. Elle permet de maintenir la qualité de service pour les voisins et autres locataires à l’aide de la ressource partagée.
* Les environnements de cloud sont créés à l’aide du très grand nombre d’unités de matériel de marchandise. Qu’ils offrent des performances par répartition dynamique de la charge entre plusieurs unités informatiques et les composants de l’infrastructure et fournir la fiabilité en recyclage automatiquement ou en remplaçant les unités défectueuses. Cette nature dynamique signifie que des erreurs transitoires et les échecs de connexion temporaires peuvent occasionnellement survenir.
* Il existe souvent plusieurs composants matériels, y compris les infrastructures de réseau tels que les routeurs et les équilibreurs de charge entre l’application et les ressources et les services qu’il utilise. Cette infrastructure supplémentaire peut parfois introduire latence de connexion supplémentaires et des erreurs de connexion temporaires.
* Les conditions de réseau entre le client et le serveur peuvent être variable, en particulier lorsque la communication traverse Internet. Même dans les emplacements sur site, les charges de trafic très importante peuvent communication lente et provoquer des échecs de connexion intermittents.

## <a name="challenges"></a>Défis
Défaillances temporaires peuvent avoir un impact important sur la perception de la disponibilité d’une application, même si elle a été soigneusement testée dans toutes les circonstances prévisibles. Pour vous assurer que les applications hébergées par le nuage continuer de manière fiable, ils doivent être en mesure de répondre aux défis suivants :

* L’application doit être en mesure de détecter les défaillances lorsqu’ils se produisent et déterminent si ces défauts sont susceptibles d’être transitoire, la plus longue durée, ou est des défaillances de Terminal Server. Différentes ressources sont susceptibles de renvoyer des réponses différentes lorsqu’une erreur se produit, et ces réponses peuvent également varier selon le contexte de l’opération ; par exemple, la réponse à une erreur lors de la lecture à partir du stockage peut être différente de la réponse d’erreur lors de l’écriture dans le stockage. De nombreuses ressources et services disposent de contrats de bien documenté échec passager. Toutefois, si ces informations ne sont pas disponibles, il peut être difficile de découvrir la nature de la panne et si elle est susceptible d’être transitoire.
* L’application doit être capable de recommencer l’opération si elle détermine que le problème est susceptible d’être transitoires et de suivre le nombre de fois que l’opération a été tentée à nouveau.
* L’application doit utiliser une stratégie appropriée pour les tentatives. Cette stratégie spécifie le nombre de tentatives, le délai entre chaque tentative et les actions à prendre après un échec. Le nombre de tentatives et le délai entre chacun d’eux est souvent difficile à déterminer et varient en fonction du type de ressource, ainsi que les conditions d’exploitation actuelles de la ressource et de l’application elle-même.

## <a name="general-guidelines"></a>Instructions générales
Les instructions suivantes vous aideront à concevoir une défaillance transitoire appropriée mécanisme pour vos applications de gestion :

* **Déterminer s’il existe un mécanisme de réitération intégré :**
  * De nombreux services fournissent une bibliothèque SDK ou client qui contient une erreur transitoire, mécanisme de gestion. La stratégie de tentatives qu’il utilise est généralement adaptée à la nature et de la configuration requise du service cible. Également, reste les interfaces des services peuvent retourner des informations qui est utiles pour déterminer si une nouvelle tentative est approprié et combien de temps à attendre avant la prochaine tentative.
  * Utilisez le mécanisme de réitération intégré où un est disponible, sauf si vous avez des besoins spécifiques et bien compris qui ont qu'un comportement différent de nouvelle tentative est plus approprié.
* **Déterminer si l’opération est adaptée à une nouvelle tentative**:
  * Vous devriez réessayer uniquement les opérations où les erreurs sont transitoires (généralement indiqué par la nature de l’erreur) et s’il y a au moins une probabilité que l’opération réussira lorsque retenté. Il est inutile de réessayer des opérations qui indiquent une opération non valide, par exemple une base de données mise à jour d’un élément qui n’existe pas, ou les demandes à un service ou une ressource qui a subi une erreur irrécupérable
  * En général, vous devez implémenter les tentatives que si toutes les conséquences de ce qui peuvent être déterminé, et si les conditions sont bien comprises et peuvent être validées. Si ce n’est pas le cas, laisser le code appelant à mettre en œuvre des nouvelles tentatives. N’oubliez pas que les erreurs renvoyées à partir des ressources et services en dehors de votre contrôle peuvent évoluer au fil du temps, vous devrez revisiter votre logique de détection de panne temporaire.
  * Lorsque vous créez des services ou des composants, envisagez la mise en oeuvre des codes d’erreur et les messages qui aideront les clients à déterminer si elles doivent réessayer des opérations n’a pas pu. En particulier, indiquez si le client doit réessayer l’opération (par exemple en retournant une valeur **isTransient** ) et suggère un délai approprié avant la prochaine tentative. Si vous créez un service web, envisagez de retourner des erreurs personnalisées définies dans les contrats de service. Même si les clients génériques n’est peut-être pas en mesure de lire ces documents, ils seront utiles lors de la création de clients personnalisés.
* **Déterminer un nombre approprié de nouvelles tentatives et l’intervalle :**
  * Il est essentiel d’optimiser le nombre de tentatives et l’intervalle pour le type de cas d’usage. Si vous ne pas réessayez un nombre suffisant de fois, l’application ne pourra pas terminer l’opération et est susceptible de rencontrer un échec. Si vous réessayez trop de fois, ou avec trop court intervalle entre tentatives, l’application peut potentiellement contenir les ressources telles que des threads, des connexions et de mémoire pendant de longues périodes, ce qui aura incidence sur la santé de l’application.
  * Les valeurs appropriées pour l’intervalle de temps et le nombre de tentatives de connexion varient selon le type d’opération tentée. Par exemple, si l’opération fait partie d’une intervention de l’utilisateur, l’intervalle doit être courte et seulement quelques tentatives pour éviter de faire attendre une réponse des utilisateurs (qui contient les connexions ouvertes et peuvent réduire la disponibilité des autres utilisateurs). Si l’opération fait partie d’un flux de travail longue en cours d’exécution ou critique, d’où l’annulation et le redémarrage du processus sont onéreux ou fastidieux, il est approprié d’attendre plus longtemps entre les tentatives et recommencer plusieurs fois.
  * Déterminer les intervalles entre les tentatives est la partie la plus difficile de la conception d’une stratégie réussie. Les stratégies par défaut utilisent les types suivants de l’intervalle avant nouvelle tentative :
      * **Recul exponentiel**. L’application attend un peu de temps avant la première nouvelle tentative, alors l’augmentation exponentielle de temps entre chaque tentative ultérieure. Par exemple, elle peut réessayer l’opération après 3 secondes, 12 secondes, 30 secondes et ainsi de suite.
      * **Intervalles incrémentielles**. L’application attend un peu de temps avant la première nouvelle tentative et puis incrémentiel heures entre chaque nouvelle tentative ultérieure. Par exemple, elle peut réessayer l’opération après 3 secondes, 7 secondes, 13 secondes et ainsi de suite.
      * **Intervalles réguliers**. L’application attend pour la même période de temps entre chaque tentative. Par exemple, il peut réessayer l’opération toutes les 3 secondes.
      * Les **tentatives d’exécution**. Une erreur passagère est parfois très courte, peut-être dû à un événement tel qu’une collision de paquets de réseau ou d’un pic dans un composant matériel. Dans ce cas, une nouvelle tentative de l’opération immédiatement convient, car il peut réussir si l’erreur a disparu dans la durée de l’application pour assembler et envoyer la demande suivante. Toutefois, il doit être jamais de plus d’une tentative immédiate, et vous devez passer à des stratégies alternatives, telles que par exemple recul exponentielle ou actions de secours, en cas d’échec de la tentative d’exécution.
      * **Sélection aléatoire**. De la nouvelle tentative stratégies ci-dessus peut inclure un sélection aléatoire pour éviter que plusieurs instances du client qui envoie les tentatives suivantes en même temps. Par exemple, une instance peut réessayer l’opération après 3 secondes, 11 secondes, 28 secondes et ainsi de suite pendant une autre instance peut réessayer l’opération après 4 secondes, 12 secondes, 26 secondes, et ainsi de suite. Sélection aléatoire est une technique utile qui peut être combinée avec d’autres stratégies.  
  * En règle générale, utilisez une stratégie de recul exponentielle pour des opérations d’arrière-plan et les stratégies de réessayer d’intervalle immédiate ou régulière pour opérations interactives. Dans les deux cas, vous devez choisir le délai et le nombre de tentatives que la latence maximale pour toutes les nouvelles tentatives dans la spécification de latence de bout en bout requis.
  * Tenir compte de la combinaison de tous les facteurs qui contribuent au délai d’attente global maximal pour une opération tentée. Ces facteurs incluent le temps nécessaire pour une connexion ayant échoué produire une réponse (valeur généralement définie par une valeur de délai d’attente du client), ainsi que le délai entre les tentatives et le nombre maximal de nouvelles tentatives. Le total de toutes ces heures peut entraîner une opération globale très grande temps, en particulier lorsque à l’aide d’une stratégie de délai exponentielle où l’intervalle entre les tentatives s’accroît rapidement après chaque échec. Si un processus doit répondre à un contrat de niveau de service spécifique (SLA), la durée de l’opération globale, y compris tous les délais d’attente et des retards, doit être dans cet définis dans le contrat SLA
  * Stratégies de nouvelles tentatives over-AGGRESSIVE, qui ont des intervalles trop courts ou trop de tentatives peuvent peuvent avoir un effet néfaste sur la ressource cible ou d’un service. Cela peut empêcher la ressource ou le service de récupération à partir de son état surchargé, et il va continuer à bloquer ou à refuser des demandes. Ce se traduit par un cercle vicieux où plus de demandes sont envoyées à la ressource ou service et par conséquent sa capacité à récupérer est plus réduite.
  * Prendre en compte le délai d’attente des opérations lorsque vous choisissez les intervalles afin d’éviter le lancement d’une nouvelle tentative immédiatement (par exemple, si le délai d’expiration est similaire à l’intervalle avant nouvelle tentative). Envisagez également si vous devez conserver la totale période possible (le délai d’attente plus les intervalles) à ci-dessous une durée spécifique. Les opérations qui ont des délais exceptionnellement courts ou très longs peuvent influencer combien de temps d’attente et la fréquence de recommencer l’opération.
  * Utilisez le type de l’exception et les données qu’il contient, ou les codes d’erreur et les messages renvoyés par le service, afin d’optimiser l’intervalle et le nombre de tentatives. Pour exemple, certaines exceptions ou codes d’erreur (telles que du code HTTP 503 Service non disponible avec un en-tête Retry-After dans la réponse) peuvent indiquer la durée pendant laquelle l’erreur peut durer, ou que le service a échoué et ne répondra pas à toute tentative ultérieure.
* **Évitez les anti-modèles**:
  * Dans la grande majorité des cas, vous devez éviter des implémentations qui incluent des calques dupliqués de code de la nouvelle tentative. Évitez les designs qui inclut des mécanismes de nouvelle tentative en cascade, ou qui implémentent recommencer à chaque étape d’une opération qui implique une hiérarchie de demandes, à moins d’avoir des exigences spécifiques qui nécessitent ce. Dans ces circonstances exceptionnelles, utiliser des stratégies qui empêchent un nombre excessif de tentatives et les périodes de délai et assurez-vous que vous comprenez les conséquences. Par exemple, si un composant fait une demande à un autre, les accès puis le service cible et que vous implémentez réessayer avec un nombre de trois sur les deux appels, il y aura neuf réessayer tente au total sur le service. De nombreux services et ressources implémentent un mécanisme de réitération intégré et que vous devez examiner comment vous pouvez désactiver ou modifier cette option si vous avez besoin mettre en œuvre des nouvelles tentatives à un niveau supérieur.
  *  Jamais implémenter un mécanisme de nouvelle tentative infinie. Ceci est susceptible d’empêcher la ressource ou le service de récupération à partir des situations de surcharge et provoquer la limitation et refusée de connexion pour une période plus longue. Utilisez un nombre fini ou tentatives ou implémenter un modèle de [disjoncteur](http://msdn.microsoft.com/library/dn589784.aspx) à autoriser le service à récupérer.
  * Ne jamais effectuer une nouvelle tentative immédiate de plus d’une fois.
  * Évitez d’utiliser un intervalle régulier, en particulier lorsque vous avez un grand nombre de tentatives de connexion, lors de l’accès aux services et aux ressources dans Azure. L’approche optimale est que ce scénario est une stratégie de recul exponentielle avec une capacité de disjoncteur.
  * Empêcher plusieurs instances du même client, ou plusieurs instances de clients différents, d’envoyer des tentatives au même moment. Si cela est susceptible de se produire, introduire la randomisation dans les intervalles.
* **Testez votre stratégie de reprise et de la mise en oeuvre :**
  * Prenez soin de que tester entièrement votre mise en œuvre de la stratégie réessayer sous large en tant qu’ensemble de conditions que possible, surtout si à la fois l’application et les ressources de la cible ou les services qu’il utilise sont sous charge extrême. Pour vérifier le comportement au cours des tests, vous pouvez :
      * Injecter des erreurs transitoires et non transitoires dans le service. Par exemple, envoyer les requêtes non valides ou ajouter du code qui détecte le test demande et répond avec différents types d’erreurs. Pour obtenir un exemple à l’aide de TestApi, consultez la section [Panne d’Injection test avec TestApi](http://msdn.microsoft.com/magazine/ff898404.aspx) et [Présentation des TestApi – partie 5 : Managed Code panne d’Injection API](http://blogs.msdn.com/b/ivo_manolov/archive/2009/11/25/9928447.aspx).
      * Créer un simulacre de la ressource ou le service qui renvoie une plage d’erreurs qui le service réel peut retourner. Garantir la couverture de tous les types d’erreur votre stratégie de nouvelle tentative est conçu pour détecter.
      * Forcer des erreurs transitoires se produise en désactivant temporairement ou de surcharge du service s’il s’agit d’un service personnalisé que vous avez créé et déployé (vous, bien sûr, n’essayez pas de surcharger les ressources partagées ou des services dans Azure partagés).
      * Pour les API basés sur HTTP, envisagez d’utiliser la bibliothèque FiddlerCore dans vos tests automatisés pour modifier le résultat des demandes HTTP, en ajoutant le temps d’aller-retour supplémentaires ou en modifiant la réponse (par exemple, le code d’état HTTP, en-têtes, corps ou d’autres facteurs). Ceci permet de tester déterministes d’un sous-ensemble de conditions de défaillance, si elle est transitoire défauts ou autres types de panne. Pour plus d’informations, consultez [FiddlerCore](http://www.telerik.com/fiddler/fiddlercore). Pour obtenir des exemples d’utilisation de la bibliothèque, en particulier la classe **HttpMangler** , examinez le [code source pour le Kit de développement de stockage Azure](https://github.com/Azure/azure-storage-net/tree/master/Test).
      * Effectuer le facteur de charge élevée et des tests pour vous assurer que le mécanisme de nouvelle tentative et une stratégie gagnante correctement dans ces conditions et ne pas avoir un effet néfaste sur le fonctionnement du client ou entraîner une contamination croisée entre les demandes simultanées.
* **Gérer les configurations de stratégie de nouvelles tentatives :**
  * Une _nouvelle tentative de stratégie_ est une combinaison de tous les éléments de votre stratégie de nouvelle tentative. Il définit le mécanisme de détection qui détermine si une erreur est susceptible d’être transitoire, le type d’intervalle à utiliser (par exemple, Normal, exponentiel recul et traitement aléatoire), les valeurs réelles d’intervalle et le nombre de fois pour réessayer.
  * Nouvelles tentatives doivent être implémentées dans de nombreux endroits au sein même de l’application la plus simple et dans chaque couche d’applications plus complexes. Au lieu de coder en dur les éléments de chaque stratégie à plusieurs emplacements, envisagez l’utilisation d’un point central pour le stockage de toutes les stratégies. Par exemple, stocker les valeurs de l’intervalle de tentatives dans les fichiers de configuration d’application, les lire au moment de l’exécution et par programme développer les stratégies de nouvelle tentative. Cela rend plus facile à gérer les paramètres et à modifier et affiner les valeurs afin de répondre à l’évolution des impératifs et les scénarios. Cependant, concevoir le système pour stocker les valeurs plutôt que de relire une configuration chaque fois que le fichier et vérifiez que les paramètres par défaut appropriés sont utilisés si les valeurs ne peuvent pas être obtenues à partir de la configuration.
  * Dans une application de Services en nuage Azure, envisagez de stocker les valeurs qui sont utilisées pour créer les stratégies de nouvelle tentative en cours d’exécution dans le fichier de configuration de service afin qu’ils peuvent être modifiés sans avoir à redémarrer l’application.
  * Profiter d’intégré ou par défaut des stratégies de reprise disponible dans le client API que vous utilisez, mais uniquement s’ils sont appropriés à votre scénario. Ces stratégies sont généralement à usage général. Dans certains scénarios, ils peuvent être tout ce qui est requis, mais dans d’autres scénarios ils ne peuvent pas offrir la gamme complète d’options pour l’adapter à vos besoins spécifiques. Vous devez comprendre comment les paramètres affectera votre application de test pour déterminer les valeurs plus appropriés.
* **Ouvrir une session et effectuer le suivi des erreurs transitoires et non transitoire :**
  * Dans le cadre de votre stratégie de nouvelle tentative, incluent la gestion des exceptions et autre instrumentation qui enregistre les nouvelles tentatives sont effectuées. Un occasionnel échec passager et nouvelle tentative sont à prévoir et n’indiquent pas un problèmes, régulières et augmenter les numéros de tentatives sont souvent un indicateur d’un problème qui peut entraîner une défaillance ou est actuellement un impact sur la disponibilité et les performances de l’application.
  * Journal des défaillances temporaires comme entrées d’avertissement plutôt qu’erreur afin que les systèmes de surveillance ne détectent pas les comme des erreurs d’application qui peuvent déclencher de fausses alertes.
  * Envisagez de stocker une valeur dans les écritures de journal qui indique si les tentatives ont été causés par la limitation dans le service, ou par d’autres types de défauts tels que les échecs de connexion, de sorte que vous pouvez les différencier lors de l’analyse des données. Une augmentation du nombre d’erreurs de limitation est souvent un indicateur d’un défaut de conception dans l’application ou de la nécessité de passer à un service premium offre un matériel dédié.  
  * Envisagez de mesure et d’enregistrement de la durée globale pour les opérations qui incluent un mécanisme de nouvelle tentative. Il s’agit d’un bon indicateur de l’impact global des défaillances temporaires sur les temps de réponse utilisateur, la latence du processus et l’efficacité de l’application de cas d’usage. Également le nombre de tentatives de journal s’est produite pour comprendre les facteurs qui ont contribué à l’heure de réponse.
  * Pensez à implémenter une télémétrie et surveillance du système qui peut déclencher des alertes lorsque le nombre et les taux d’échecs, le nombre moyen de tentatives ou augmente le temps global pris de telles opérations réussissent.
* **Gérer les opérations échouent continuellement :**
  * Il y aura des cas où l’opération se poursuit à chaque tentative d’échouer, et il est essentiel de prendre en compte la façon dont vous allez gérer cette situation :
      * Bien qu’une stratégie de nouvelles tentatives définit le nombre maximal de fois où une opération doit être retentée, elle n’empêche pas l’application de répéter l’opération à nouveau, avec le même nombre de nouvelles tentatives. Par exemple, si un service de traitement des commandes échoue avec une erreur irrécupérable qui place définitivement hors d’action, la stratégie de nouvelle tentative peut détecter un délai d’expiration de la connexion et pensez qu’il s’agit d’une erreur transitoire. Le code va réessayer l’opération un nombre spécifié de fois et puis abandonner. Toutefois, lorsqu’un autre client passe une commande, l’opération sera tentée à nouveau - même s’il est sûr échec chaque fois.
      * Pour empêcher les tentatives en continu pour les opérations qui échouent en permanence, envisagez l’implémentation du [modèle de disjoncteur](http://msdn.microsoft.com/library/dn589784.aspx). Dans ce modèle, si le nombre d’échecs dans une fenêtre de temps spécifiée dépasse le seuil, demandes sont retournés à l’appelant immédiatement en tant qu’erreurs, sans tenter d’accéder à la ressource a échoué ou le service.
      * L’application peut tester régulièrement le service, par intermittence et avec très longs intervalles entre les demandes, et pour détecter lorsqu’il est disponible. Un intervalle approprié dépend du scénario, telles que la priorité de l’opération et la nature du service et peut être n’importe quoi entre quelques minutes et plusieurs heures. Au point où le test a réussi, l’application peut reprendre les opérations normales et transmettre les requêtes au service nouvellement restauré.
      * En attendant, il peut être possible de revenir à une autre instance du service (peut-être dans un autre centre de données ou une application), utiliser un service similaire qui offre une fonctionnalité compatible (voire plus simple) ou effectuer des opérations de remplacement dans l’espoir que le service ne sera bientôt plus disponible. Par exemple, il peut être utile de stocker des requêtes pour le service dans une file d’attente ou le magasin de données et les relire plus tard. Dans le cas contraire vous pourrez peut-être rediriger l’utilisateur vers une autre instance de l’application, de dégrader les performances de l’application, mais toujours offrent des fonctionnalités acceptable, ou présenter de retour simplement un message à l’utilisateur indiquant que l’application n’est pas disponible à l’adresse.

* **Autres considérations**
  * Lorsque vous choisissez les valeurs pour le nombre de tentatives et des intervalles de relance pour une stratégie, considérez si l’opération sur le service ou la ressource fait partie d’une opération de longue durée ou à plusieurs étapes. Il peut être difficile ou coûteux de compenser toutes les autres étapes opérationnelles qui ont déjà réussi, un échec de. Dans ce cas, un intervalle très long et un grand nombre de nouvelles tentatives peuvent être acceptables dans la mesure où il ne bloque pas d’autres opérations en attente ou verrouillage des ressources limitées.
  * Prendre en compte si le nouvel essai la même opération peut entraîner des incohérences dans les données. Si certaines parties d’un processus à plusieurs étapes sont répétées, et les opérations ne sont pas idempotent, elle peut entraîner une incohérence. Par exemple, une opération qui incrémente une valeur, si répétée, produira un résultat non valide. Répéter une opération qui envoie un message à une file d’attente peut entraîner une incohérence dans le consommateur de messages si elle ne peut pas détecter les messages en double. Pour éviter cela, assurez-vous que chaque étape comme une opération équipotentes. Pour plus d’informations sur l’idempotence, reportez-vous [Aux modèles idempotence](http://blog.jonathanoliver.com/2010/04/idempotency-patterns/).
  * Pensez à la portée des opérations sera tentée à nouveau. Par exemple, il peut être plus facile d’implémenter le code de recommencer à un niveau qui englobe plusieurs opérations et toutes les tentatives en cas de panne. Toutefois, cela peut entraîner les problèmes idempotence ou les opérations de restauration inutiles.
  * Si vous choisissez une portée de nouvelles tentatives qui englobe plusieurs opérations, prendre en compte la latence totale de tous les pour déterminer les intervalles, lors de l’analyse de la durée d’avant de déclencher des alertes pour les échecs.
  * Pensez comment votre stratégie de nouvelles tentatives peut-être affecter voisins et autres locataires dans une application partagée, ou lors de l’utilisation des services et des ressources partagées. Stratégies de réessayer agressif peuvent entraîner un nombre croissant de défaillances temporaires pour ces autres utilisateurs et pour les applications qui partagent les ressources et les services. De même, votre application peut-être être affectée par les politiques de réessayer mis en oeuvre par d’autres utilisateurs des ressources et des services. Pour les applications critiques, vous pouvez décider d’utiliser les services de prime qui ne sont pas partagées. Cela vous donne beaucoup plus de contrôle sur la charge et de la limitation à la suite de ces ressources et de services, ce qui peuvent aider à justifier le coût supplémentaire.

## <a name="more-information"></a>Plus d’informations

* [Instructions d’Azure réessayer de service spécifique](best-practices-retry-service-specific.md)
* [Le bloc d’Application de gestion des erreurs transitoires](http://msdn.microsoft.com/library/hh680934.aspx)
* [Modèle de disjoncteur](http://msdn.microsoft.com/library/dn589784.aspx)
* [Modèle de Transaction de compensation](http://msdn.microsoft.com/library/dn589804.aspx)
* [Modèles d’idempotence](http://blog.jonathanoliver.com/2010/04/idempotency-patterns/)
